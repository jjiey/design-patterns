设计模式的原则：
1.单一职责原则：
        就一个类而言，应该仅有一个引起它变化的原因。
        如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
        软件设计真正要做的内容，就是发现职责并把那些职责相互分离。
        如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。
2.开放-封闭原则：
        软件实体应该可以扩展，但是不可修改。
        两个原则：对于扩展是开放的（Open for extension）；对于更改是封闭的（Closed for modification）。
        怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？
        无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对干他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。
        等到变化发生时立即采取行动。
        在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
        面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。
        我们希望的是在开发工作展开不久就知道可能发生的变化，查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。
        开放－封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对干应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。
3.依赖倒转原则：
        抽象不应该依赖细节，细节应该依赖于抽象。（针对接口编程，不要对实现编程）
        A.高层模块不应该依赖低层模块。两个都应该依赖抽象。B.抽象不应该依赖细节。细节应该依赖抽象。
        里氏代换原则：
            一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。（简单地说，子类型必须能够替换掉它们的父类型）
            只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
            由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。
        依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。



迪米特法则：（最少知识原则）
        如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
        在类的结构设计上，每一个类都应当尽量降低成员的访问权限。
        根本思想是强调了类之间的松耦合。
        类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。

合成/聚合复用原则：
        尽量使用合成/聚合，尽量不要使用类继承。
        聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分；
        合成则是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。
        好处：优先使用对象的合成/聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。



创建型模式：这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
    工厂模式（Factory Pattern）
    抽象工厂模式（Abstract Factory Pattern）
    单例模式（Singleton Pattern）
    建造者模式（Builder Pattern）
    原型模式（Prototype Pattern）
结构型模式：这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
    适配器模式（Adapter Pattern）
    桥接模式（Bridge Pattern）
    //过滤器模式（Filter、Criteria Pattern）
    组合模式（Composite Pattern）
    装饰器模式（Decorator Pattern）
    外观模式（Facade Pattern）
    享元模式（Flyweight Pattern）
    代理模式（Proxy Pattern）
行为型模式：这些设计模式特别关注对象之间的通信。
    责任链模式（Chain of Responsibility Pattern）
    命令模式（Command Pattern）
    解释器模式（Interpreter Pattern）
    迭代器模式（Iterator Pattern）
    中介者模式（Mediator Pattern）
    备忘录模式（Memento Pattern）
    观察者模式（Observer Pattern）
    状态模式（State Pattern）
    //空对象模式（Null Object Pattern）
    策略模式（Strategy Pattern）
    模板模式（Template Pattern）
    访问者模式（Visitor Pattern）