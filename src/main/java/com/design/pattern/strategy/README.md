## 策略模式（行为型）

Strategy Design Pattern

策略模式 VS 工厂模式：策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿。

### 定义

在 GoF 的《设计模式》一书中，它是这样定义的：

> Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

翻译：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。

### 解决问题

将策略的定义、创建、使用这三部分解耦

### 应用场景举例

最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断（状态模式也可以）
也可以提供框架的扩展点

给文件排序（demo4）：写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。

### code

demo1：大话设计模式

demo2：

demo3：缓存驱逐策略

demo4：应用场景
v1：堆代码
v2：策略模式第一步：将策略的定义分离
v3：策略模式
v4：彻底消除 if-else 逻辑
v5：为了更符合开闭原则，做到新增策略对类不进行修改，可以通过反射来避免对策略工厂类的修改。具体这么做：通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可。

------

它定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。