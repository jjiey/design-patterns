## 工厂模式（创建型）

Factory Design Pattern

工厂模式分为三种更加细分的类型：简单工厂（Simple Factory）、工厂方法（Factory Method）和抽象工厂（Abstract Factory）

自己理解：工厂方法相比于简单工厂可以屏蔽具体的 new 细节（假如初始化时要组合其他类对象，做各种初始化操作时是有必要屏蔽的；否则就会有一个庞大的简单工厂类），好处：封装变化、代码复用、隔离复杂性、控制复杂度

### 定义

在 GoF 的《设计模式》一书中，它将简单工厂模式看作是工厂方法模式的一种特例，所以工厂模式只被分成了工厂方法和抽象工厂两类。

工厂方法模式 VS 简单工厂模式：
当**对象的创建逻辑比较复杂**，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。

### 解决问题

### 应用场景举例

加减乘除 demo1

根据配置文件的后缀（json、xml、yaml、properties），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的配置解析成内存对象 RuleConfig demo2/demo3

需求增加：既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类（抽象工厂可以有效的减少工厂类个数；否则，这个需求就需要 8 个 parser 类，类越来越多） demo4

### code

demo1：大话设计模式 应用场景

demo2（simplefactory）：应用场景
v1：简单实现
v2：将独立功能的代码块封装成函数（createParser）
v3：简单工厂模式
v4：简单工厂模式 提前缓存，复用，节省内存和对象创建的时间

简单工厂模式的代码实现中，有多处 if 分支判断逻辑，违背开闭原则。（但权衡扩展性和可读性，这样的代码实现在大多数情况下（比如，不需要频繁地添加 parser，也没有太多的 parser）是没有问题的）

工厂方法模式比起简单工厂模式更加符合开闭原则。为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。

demo3（factorymethod）：应用场景
v1：改为工厂类
v2：为工厂类再创建一个简单工厂

demo4（abstractfactory）：应用场景